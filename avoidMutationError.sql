-- ESTE EJEMPLO NOS SIRVE PARA REFLEJAR ELIMINACIÓN SIMULTÁNEA ENTRE DISTINTAS TABLAS, A TRAVÉS DE UN TRIGGER,
-- Y QUE NO NOS SALTE EL AVISO DE MUTATION ERROR


CREATE OR REPLACE TRIGGER delete_order_when_no_items
AFTER DELETE ON DEMO_ORDER_ITEMS
REFERENCING NEW AS new OLD AS old -- PROBAR SI FUNCIONA SIN ESTO, REFERENCIANDO OLD Y NEW DIRECTAMENTE.
FOR EACH ROW 
DECLARE
    order_amount NUMBER(10);
    price_diference number (10, 2) := :old.UNIT_PRICE * :old.QUANTITY;
    current_amount number(10, 2);
BEGIN
    SELECT ORDER_TOTAL INTO order_amount
    FROM DEMO_ORDERS
    WHERE DEMO_ORDERS.ORDER_ID = :OLD.ORDER_ID;
    
    current_amount := order_amount - price_diference;
    INSERT INTO DEMO_LOGS VALUES ('Contador: ' || order_amount || ' Real: ' || order_amount - price_diference);+
    
    IF current_amount <= 0 THEN
        DELETE FROM DEMO_ORDERS WHERE order_id = :old.order_id;
    END IF;
END;
/
SELECT COUNT (DEMO_ORDERS.ORDER_ID) INTO order_num_of_rows
FROM DEMO_ORDERS
LEFT JOIN DEMO_ORDER_ITEMS
ON DEMO_ORDER_ITEMS.ORDER_ID = DEMO_ORDERS.ORDER_ID
WHERE DEMO_ORDERS.ORDER_ID = :OLD.ORDER_ID
GROUP BY DEMO_ORDERS.ORDER_ID;